<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="7RxIs#qU8mT|DYU6}jK7" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id=":{-DH|rfHb_w%W;U_lZn" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace OLED {" line1="    let font = [0x0022d422, 0x0022d422, 0x0022d422, 0x0022d422, 0x0022d422, 0x0022d422, 0x0022d422, 0x0022d422, 0x0022d422, 0x0022d422," line2="        0x0022d422, 0x0022d422, 0x0022d422, 0x0022d422, 0x0022d422, 0x0022d422, 0x0022d422, 0x0022d422, 0x0022d422, 0x0022d422," line3="        0x0022d422, 0x0022d422, 0x0022d422, 0x0022d422, 0x0022d422, 0x0022d422, 0x0022d422, 0x0022d422, 0x0022d422, 0x0022d422," line4="        0x0022d422, 0x0022d422, 0x00000000, 0x000002e0, 0x00018060, 0x00afabea, 0x00aed6ea, 0x01991133, 0x010556aa, 0x00000060," line5="        0x000045c0, 0x00003a20, 0x00051140, 0x00023880, 0x00002200, 0x00021080, 0x00000100, 0x00111110, 0x0007462e, 0x00087e40," line6="        0x000956b9, 0x0005d629, 0x008fa54c, 0x009ad6b7, 0x008ada88, 0x00119531, 0x00aad6aa, 0x0022b6a2, 0x00000140, 0x00002a00," line7="        0x0008a880, 0x00052940, 0x00022a20, 0x0022d422, 0x00e4d62e, 0x000f14be, 0x000556bf, 0x0008c62e, 0x0007463f, 0x0008d6bf," line8="        0x000094bf, 0x00cac62e, 0x000f909f, 0x000047f1, 0x0017c629, 0x0008a89f, 0x0008421f, 0x01f1105f, 0x01f4105f, 0x0007462e," line9="        0x000114bf, 0x000b6526, 0x010514bf, 0x0004d6b2, 0x0010fc21, 0x0007c20f, 0x00744107, 0x01f4111f, 0x000d909b, 0x00117041," line10="        0x0008ceb9, 0x0008c7e0, 0x01041041, 0x000fc620, 0x00010440, 0x01084210, 0x00000820, 0x010f4a4c, 0x0004529f, 0x00094a4c," line11="        0x000fd288, 0x000956ae, 0x000097c4, 0x0007d6a2, 0x000c109f, 0x000003a0, 0x0006c200, 0x0008289f, 0x000841e0, 0x01e1105e," line12="        0x000e085e, 0x00064a4c, 0x0002295e, 0x000f2944, 0x0001085c, 0x00012a90, 0x010a51e0, 0x010f420e, 0x00644106, 0x01e8221e," line13="        0x00093192, 0x00222292, 0x00095b52, 0x0008fc80, 0x000003e0, 0x000013f1, 0x00841080, 0x0022d422];" line14="    // 0x0022d422 -&gt; &quot;?&quot;" line15="" line16="    let PAGE_NUM = 8" line17="    let COLUMN_NUM = 132" line18="    let FONT_SIZE = 5" line19="" line20="    let _I2CAddr = 0;" line21="    let _screen = pins.createBuffer(PAGE_NUM * COLUMN_NUM + 1);" line22="    let _buf2 = pins.createBuffer(2);" line23="    let _buf3 = pins.createBuffer(3);" line24="    let _buf4 = pins.createBuffer(4);" line25="    let _ZOOM = 0;" line26="" line27="    function cmd1(d: number) {" line28="        let n = d % 256;" line29="        pins.i2cWriteNumber(_I2CAddr, n, NumberFormat.UInt16BE);" line30="    }" line31="" line32="    function cmd2(d1: number, d2: number) {" line33="        _buf3[0] = 0;" line34="        _buf3[1] = d1;" line35="        _buf3[2] = d2;" line36="        pins.i2cWriteBuffer(_I2CAddr, _buf3);" line37="    }" line38="" line39="    function cmd3(d1: number, d2: number, d3: number) {" line40="        _buf4[0] = 0;" line41="        _buf4[1] = d1;" line42="        _buf4[2] = d2;" line43="        _buf4[3] = d3;" line44="        pins.i2cWriteBuffer(_I2CAddr, _buf4);" line45="    }" line46="" line47="    function set_pos(col: number = 0, page: number = 0) {" line48="        cmd1(0xb0 | page) // page number" line49="        //        let c = col * (_ZOOM + 1)" line50="        let c = col * (_ZOOM + 1) + 2 // for SH1106" line51="        cmd1(0x00 | (c % 16)) // lower start column address" line52="        cmd1(0x10 | (c &gt;&gt; 4)) // upper start column address    " line53="    }" line54="" line55="    // clear bit" line56="    function clrbit(d: number, b: number): number {" line57="        if (d &amp; (1 &lt;&lt; b))" line58="            d -= (1 &lt;&lt; b)" line59="        return d" line60="    }" line61="" line62="    function setBitColor(buffer:number, page:number, color:number): number {" line63="        if(color) {" line64="            return buffer | (1 &lt;&lt; page)" line65="        }" line66="        else {" line67="            return clrbit(buffer, page)" line68="        }" line69="    }" line70="" line71="    //% blockId=&quot;TEST_CODE&quot; block=&quot;test code&quot;" line72="    //% weight=70 blockGap=8" line73="    //% parts=OLED trackArgs=0" line74="    export function testCode() {" line75="        showImage(1)" line76="        OLED.showString(" line77="            10," line78="            7," line79="            &quot;Hello!&quot;," line80="            1" line81="        )" line82="    }" line83="" line84="    /**" line85="     * show image" line86="     * @param x is X alis, eg: 0" line87="     */" line88="    //% blockId=&quot;OLED_SHOW_IMAGE&quot; block=&quot;show image at imageNo %imageNo&quot;" line89="    //% weight=70 blockGap=8" line90="    //% parts=OLED trackArgs=0" line91="    export function showImage(imageNo: number) {" line92="        for (let drawPage = 0; drawPage &lt; PAGE_NUM; drawPage++) {" line93="            for (let i = 0; i &lt; COLUMN_NUM;i++) {" line94="                let screenIdx = i + drawPage * COLUMN_NUM" line95="                let imageIdx = i + drawPage * 128" line96="                if(imageNo = 1)     _screen[screenIdx] = OLED_IMAGE.face1[imageIdx];" line97="                else                _screen[screenIdx] = OLED_IMAGE.face2[imageIdx];" line98="            }" line99="            set_pos(0, drawPage)" line100="            let ind2 = drawPage * COLUMN_NUM + 1" line101="            let buf2 = _screen.slice(ind2, COLUMN_NUM - 1)" line102="            buf2.shift(-1)" line103="            buf2[0] = 0x40" line104="            pins.i2cWriteBuffer(_I2CAddr, buf2)" line105="        }" line106="    }" line107="" line108="    /**" line109="     * set pixel in OLED" line110="     * @param x is X alis, eg: 0" line111="     * @param y is Y alis, eg: 0" line112="     * @param color is dot color, eg: 1" line113="     */" line114="    //% blockId=&quot;OLED_PIXEL&quot; block=&quot;set pixel at x %x|y %y|color %color&quot;" line115="    //% weight=70 blockGap=8" line116="    //% parts=OLED trackArgs=0" line117="    export function pixel(x: number, y: number, color: number = 1) {" line118="        if (x &lt; 0 || x &gt; 128 || y &lt; 0 || y &gt; 62) return" line119="        let page = y &gt;&gt; 3               // ページ数(0-7)" line120="        let shift_page = y % PAGE_NUM   // ページ中の行数(0-7)" line121="        let ind = x * (_ZOOM + 1) + page * COLUMN_NUM + 1" line122="        let b = setBitColor(_screen[ind], shift_page, color)" line123="        _screen[ind] = b" line124="        set_pos(x, page)" line125="        if (_ZOOM) {" line126="            _screen[ind + 1] = b" line127="            _buf3[0] = 0x40" line128="            _buf3[1] = _buf3[2] = b" line129="            pins.i2cWriteBuffer(_I2CAddr, _buf3)" line130="        }" line131="        else {" line132="            _buf2[0] = 0x40" line133="            _buf2[1] = b" line134="            pins.i2cWriteBuffer(_I2CAddr, _buf2)" line135="        }" line136="    }" line137="" line138="    /**" line139="     * show text in OLED" line140="     * @param x is X alis, eg: 0" line141="     * @param y is Y alis, eg: 0" line142="     * @param s is the text will be show, eg: 'Hello!'" line143="     * @param color is string color, eg: 1" line144="     */" line145="    //% blockId=&quot;OLED_SHOWSTRING&quot; block=&quot;show string at x %x|y %y|text %s|color %color&quot;" line146="    //% weight=80 blockGap=8" line147="    //% parts=OLED trackArgs=0" line148="    export function showString(x: number, y: number, s: string, color: number = 1) {" line149="        let col = 0" line150="        let fontData = 0" line151="        let screenIdx2 = 0" line152="        let maxLength = _ZOOM ? 12 : 25　// 1行当たりの最大文字数" line153="        let stringLength = s.length &lt;= maxLength ? s.length : maxLength" line154="        for (let stringNo = 0; stringNo &lt; stringLength; stringNo++) {" line155="            fontData = font[s.charCodeAt(stringNo)]" line156="            for (let j = 0; j &lt; FONT_SIZE; j++) {" line157="                col = 0" line158="                for (let k = 0; k &lt; FONT_SIZE; k++) {" line159="                    if (fontData &amp; (1 &lt;&lt; (FONT_SIZE * j + k)))" line160="                        col |= (1 &lt;&lt; (k + 1))" line161="                }" line162="                screenIdx2 = (x + stringNo) * FONT_SIZE * (_ZOOM + 1) + y * COLUMN_NUM + j * (_ZOOM + 1) + 1" line163="                if (color == 0)" line164="                    col = 255 - col" line165="                _screen[screenIdx2] = col" line166="                if (_ZOOM)" line167="                    _screen[screenIdx2 + 1] = col" line168="            }" line169="        }" line170="        set_pos(x * FONT_SIZE, y)" line171="        let startIdx = x * FONT_SIZE * (_ZOOM + 1) + y * COLUMN_NUM + 1" line172="        let buf = _screen.slice(startIdx, screenIdx2 + 1)" line173="        buf.shift(-1)" line174="        buf[0] = 0x40" line175="        pins.i2cWriteBuffer(_I2CAddr, buf)" line176="        draw()  // 本当は無くしたい（1～6行目が上手く表示されない…）" line177="    }" line178="" line179="    /**" line180="     * show a number in OLED" line181="     * @param x is X alis, eg: 0" line182="     * @param y is Y alis, eg: 0" line183="     * @param num is the number will be show, eg: 12" line184="     * @param color is number color, eg: 1" line185="     */" line186="    //% blockId=&quot;OLED_NUMBER&quot; block=&quot;show a Number at x %x|y %y|number %num|color %color&quot;" line187="    //% weight=80 blockGap=8" line188="    //% parts=OLED trackArgs=0" line189="    export function showNumber(x: number, y: number, num: number, color: number = 1) {" line190="        showString(x, y, num.toString(), color)" line191="    }" line192="" line193="    /**" line194="     * draw a horizontal line" line195="     * @param x is X alis, eg: 0" line196="     * @param y is Y alis, eg: 0" line197="     * @param len is the length of line, eg: 10" line198="     * @param color is line color, eg: 1" line199="     */" line200="    //% blockId=&quot;OLED_HLINE&quot; block=&quot;draw a horizontal line at x %x|y %y|number %len|color %color&quot;" line201="    //% weight=71 blockGap=8" line202="    //% parts=OLED trackArgs=0" line203="    export function hline(x: number, y: number, len: number, color: number = 1) {" line204="        for (let l = x; l &lt; (x + len); l++)" line205="            pixel(l, y, color)" line206="    }" line207="" line208="    /**" line209="     * draw a vertical line" line210="     * @param x is X alis, eg: 0" line211="     * @param y is Y alis, eg: 0" line212="     * @param len is the length of line, eg: 10" line213="     * @param color is line color, eg: 1" line214="     */" line215="    //% blockId=&quot;OLED_VLINE&quot; block=&quot;draw a vertical line at x %x|y %y|number %len|color %color&quot;" line216="    //% weight=72 blockGap=8" line217="    //% parts=OLED trackArgs=0" line218="    export function vline(x: number, y: number, len: number, color: number = 1) {" line219="        for (let m = y; m &lt; (y + len); m++)" line220="            pixel(x, m, color)" line221="    }" line222="" line223="    /**" line224="     * draw a rectangle" line225="     * @param x1 is X alis, eg: 0" line226="     * @param y1 is Y alis, eg: 0" line227="     * @param x2 is X alis, eg: 60" line228="     * @param y2 is Y alis, eg: 30" line229="     * @param color is line color, eg: 1" line230="     */" line231="    //% blockId=&quot;OLED_RECT&quot; block=&quot;draw a rectangle at x1 %x1|y1 %y1|x2 %x2|y2 %y2|color %color&quot;" line232="    //% weight=73 blockGap=8" line233="    //% parts=OLED trackArgs=0" line234="    export function rect(x1: number, y1: number, x2: number, y2: number, color: number = 1) {" line235="        if (x1 &gt; x2)" line236="            x1 = [x2, x2 = x1][0];" line237="        if (y1 &gt; y2)" line238="            y1 = [y2, y2 = y1][0];" line239="        hline(x1, y1, x2 - x1 + 1, color)" line240="        hline(x1, y2, x2 - x1 + 1, color)" line241="        vline(x1, y1, y2 - y1 + 1, color)" line242="        vline(x2, y1, y2 - y1 + 1, color)" line243="    }" line244="" line245="    /**" line246="     * fill a rectangle" line247="     * @param x1 is X alis, eg: 0" line248="     * @param y1 is Y alis, eg: 0" line249="     * @param x2 is X alis, eg: 60" line250="     * @param y2 is Y alis, eg: 30" line251="     * @param color is line color, eg: 1" line252="     */" line253="    //% blockId=&quot;OLED_FILLRECT&quot; block=&quot;fillRect at x1 %x1|y1 %y1|x2 %x2|y2 %y2|color %color&quot;" line254="    //% weight=73 blockGap=8" line255="    //% parts=OLED trackArgs=0" line256="    export function fillRect(x1: number, y1: number, x2: number, y2: number, color: number = 1) {" line257="        for (let x = x1; x &lt;= x2; x++) {" line258="        for (let y = y1; y &lt;= y2; y++) {" line259="                pixel(x, y)" line260="            }" line261="        }" line262="    }" line263="    /**" line264="     * invert display" line265="     * @param d true: invert / false: normal, eg: true" line266="     */" line267="    //% blockId=&quot;OLED_INVERT&quot; block=&quot;invert display %d&quot;" line268="    //% weight=65 blockGap=8" line269="    //% parts=OLED trackArgs=0" line270="    export function invert(d: boolean = true) {" line271="        let q = (d) ? 0xA7 : 0xA6" line272="        cmd1(q)" line273="    }" line274="" line275="    /**" line276="     * draw / redraw screen" line277="     */" line278="    //% blockId=&quot;OLED_DRAW&quot; block=&quot;draw&quot;" line279="    //% weight=64 blockGap=8" line280="    //% parts=OLED trackArgs=0" line281="    export function draw() {" line282="        for (let drawPage2 = 0; drawPage2 &lt; PAGE_NUM; drawPage2++) {" line283="            set_pos(0, drawPage2)" line284="            let ind22 = drawPage2 * COLUMN_NUM + 1" line285="            let buf22 = _screen.slice(ind22, COLUMN_NUM - 1)" line286="            buf22.shift(-1)" line287="            buf22[0] = 0x40" line288="            pins.i2cWriteBuffer(_I2CAddr, buf22)" line289="        }" line290="    }" line291="" line292="    function clearData() {" line293="        _screen.fill(0)" line294="        _screen[0] = 0x40" line295="    }" line296="" line297="    /**" line298="     * clear screen" line299="     */" line300="    //% blockId=&quot;OLED_CLEAR&quot; block=&quot;clear&quot;" line301="    //% weight=63 blockGap=8" line302="    //% parts=OLED trackArgs=0" line303="    export function clear() {" line304="        clearData()" line305="        draw()" line306="    }" line307="" line308="    /**" line309="     * fill screen" line310="     */" line311="    //% blockId=&quot;OLED_FILL_SCREEN&quot; block=&quot;fillScreen&quot;" line312="    //% weight=63 blockGap=8" line313="    //% parts=OLED trackArgs=0" line314="    export function fillScreen() {" line315="        _screen.fill(255)" line316="        for (let o = (PAGE_NUM - 1) * COLUMN_NUM; o &lt;PAGE_NUM * COLUMN_NUM; o++) {" line317="            _screen[o] = 127    // 最後の1行だけ消す" line318="        }" line319="        _screen[0] = 0x40" line320="        draw()" line321="    }" line322="" line323="    /**" line324="     * turn on screen" line325="     */" line326="    //% blockId=&quot;OLED_ON&quot; block=&quot;display on&quot;" line327="    //% weight=62 blockGap=8" line328="    //% parts=OLED trackArgs=0" line329="    export function on() {" line330="        cmd1(0xAF)" line331="    }" line332="" line333="    /**" line334="     * turn off screen" line335="     */" line336="    //% blockId=&quot;OLED_OFF&quot; block=&quot;display off&quot;" line337="    //% weight=61 blockGap=8" line338="    //% parts=OLED trackArgs=0" line339="    export function off() {" line340="        cmd1(0xAE)" line341="    }" line342="" line343="    /**" line344="     * zoom mode" line345="     * @param d true zoom / false normal, eg: true" line346="     */" line347="    //% blockId=&quot;OLED_ZOOM&quot; block=&quot;zoom %d&quot;" line348="    //% weight=60 blockGap=8" line349="    //% parts=OLED trackArgs=0" line350="    export function zoom(d: boolean = true) {" line351="        _ZOOM = (d) ? 1 : 0" line352="        cmd2(0xd6, _ZOOM)" line353="    }" line354="" line355="    /**" line356="     * OLED initialize" line357="     * @param addr is i2c addr, eg: 60" line358="     */" line359="    //% blockId=&quot;OLED_initialize&quot; block=&quot;initialize OLED&quot;" line360="    //% weight=100 blockGap=8" line361="    //% parts=OLED trackArgs=0" line362="    export function initialize() {" line363="        _I2CAddr = 60;" line364="        _ZOOM = 0" line365="        cmd1(0xAE)       // SSD1306_DISPLAYOFF" line366="        cmd1(0xA4)       // SSD1306_DISPLAYALLON_RESUME" line367="        cmd2(0xD5, 0xF0) // SSD1306_SETDISPLAYCLOCKDIV" line368="        cmd2(0xA8, 0x3F) // SSD1306_SETMULTIPLEX" line369="        cmd2(0xD3, 0x00) // SSD1306_SETDISPLAYOFFSET" line370="        cmd1(0 | 0x0)    // line #SSD1306_SETSTARTLINE" line371="        cmd2(0x8D, 0x14) // SSD1306_CHARGEPUMP" line372="        cmd2(0x20, 0x00) // SSD1306_MEMORYMODE" line373="        cmd3(0x21, 0, 127) // SSD1306_COLUMNADDR" line374="        cmd3(0x22, 0, 63)  // SSD1306_PAGEADDR" line375="        cmd1(0xa0 | 0x1) // SSD1306_SEGREMAP" line376="        cmd1(0xc8)       // SSD1306_COMSCANDEC" line377="        cmd2(0xDA, 0x12) // SSD1306_SETCOMPINS" line378="        cmd2(0x81, 0xCF) // SSD1306_SETCONTRAST" line379="        cmd2(0xd9, 0xF1) // SSD1306_SETPRECHARGE" line380="        cmd2(0xDB, 0x40) // SSD1306_SETVCOMDETECT" line381="        cmd1(0xA6)       // SSD1306_NORMALDISPLAY" line382="        cmd2(0xD6, _ZOOM)    // zoom off" line383="        cmd1(0xAF)       // SSD1306_DISPLAYON" line384="        clear()" line385="    }" line386="}" numlines="387"></mutation><next><block type="OLED_initialize" id="q?yl/vS2POW+]c.t[u/e"></block></next></block></statement></block></xml>